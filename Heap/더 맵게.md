# 스택 / 큐

[프로그래머스 > 힙 > 기능개발](https://programmers.co.kr/learn/courses/30/lessons/42626)

## 문제

#### 문제설명

매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.

섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 \* 2)

Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.
Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.

#### 제한사항

- scoville의 길이는 2 이상 1,000,000 이하입니다.
- K는 0 이상 1,000,000,000 이하입니다.
- scoville의 원소는 각각 0 이상 1,000,000 이하입니다.
- 모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.

#### 입출력 예

| scoville             | K   | return |
| -------------------- | --- | ------ |
| [1, 2, 3, 9, 10, 12] | 7   | 2      |

#### 입출력 예 설명

1. 스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
   새로운 음식의 스코빌 지수 = 1 + (2 \* 2) = 5
   가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]

2. 스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.
   새로운 음식의 스코빌 지수 = 3 + (5 \* 2) = 13
   가진 음식의 스코빌 지수 = [13, 9, 10, 12]

모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.

## 풀이

1. 힙(우선순위 큐)을 선언해 scoville배열의 원소를 minHeap 넣어준다.
2. minHeap에서 제일 낮은 값(minHeap.peek()) 이 K보다 낮을 때만 while문을 돌린다.
3. 제일 낮은 값과, 하나 더 큰 값을 꺼내(minHeap.poll()) 연산 후 힙에 넣고 answer += 1 한다.
4. 이후, 제일 낮은 값(minHeap.peek())이 K 이상이면 종료한다.
5. 마지막수가 K보다 작을 때 answer에 -1을 대입하고 while문을 끝낸다.

```java
import java.util.*;

class Solution {
    public int solution(int[] scoville, int K) {
        int answer = 0;

        //최대 값이 우선순위인 큐 = 최대 힙, 최소 값이 우선순위인 큐 = 최소 힙

        //자동오름차순정렬
        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>();

        for (int i=0; i<scoville.length; i++) {
            minHeap.add(scoville[i]);
        }

        while (minHeap.peek() < K) {
            //제일낮은값, 제일낮은값+1 빼기
            int min1 = minHeap.poll();
            int min2 = minHeap.poll();

            //힙에 넣기
            minHeap.add(min1 + min2*2);
            answer++;

            //제일 낮은 값이 K이상이면 끝
            if (minHeap.peek() >= K) {
                break;
            }

            //마지막 수가 K보다 작을 때
            if (minHeap.peek() < K && minHeap.size() == 1) {
                answer = -1;
                break;
            }
        }

        return answer;
    }
}
```

- 고려할 점

1. 힙(우선순위 큐)을 사용할 것
2. 제일 낮은 값이 K이상일 때를 생각할 것
3. 마지막 수가 K보다 작을 때를 생각할 것

## 개념

### ⚡️ 힙

> 힙(heap)이란 완전 이진 트리의 일종으로 우선순위 큐를 위하여 만들어진 자료구조이다.
> 여러 개의 값들 중에서 최댓값이나 최솟값을 빠르게 찾아내도록 만들어진 자료구조이다.
> 힙은 일종의 반정렬 상태(느슨한 정렬 상태) 를 유지한다.
> 큰 값이 상위 레벨에 있고 작은 값이 하위 레벨에 있다는 정도
> 간단히 말하면 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰(작은) 이진 트리를 말한다.
> 힙 트리에서는 중복된 값을 허용한다. (이진 탐색 트리에서는 중복된 값을 허용하지 않는다.)

힙은 특정한 규칙을 가지는 트리로, 힙을 이용해서 우선순위 큐를 구현할 수 있습니다.

> 힙의 종류

- 최대 힙(max heap)
  부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은 완전 이진 트리
  key(부모 노드) >= key(자식 노드)

- 최소 힙(min heap)
  부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은 완전 이진 트리
  key(부모 노드) <= key(자식 노드)

> - 우선순위 큐란?
>   큐(Queue)는 먼저 들어오는 데이터가 먼저 나가는 FIFO(First In First Out) 형식의 자료구조이다.
>   우선순위 큐(Priority Queue)는 먼저 들어오는 데이터가 아니라, 우선순위가 높은 데이터가 먼저 나가는 형태의 자료구조이다.
>   우선순위 큐는 일반적으로 힙(Heap)을 이용하여 구현한다.
